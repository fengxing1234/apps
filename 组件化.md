### 组件化

1. 全局Gradle配置
2. ARoute使用
3. Application配置
4. 组件独立运行
5. Module之间的通信
6. 资源名冲突问题

#### 解决的问题

1. 单个工程编译时间过长
2. 不适合团队

### 问题

1、平时在dev-debug期间频繁改动，快照版本的版本号需要每次升级吗 ？ 2、如果版本号并非每次升级 那是自动覆盖吗？
3、debug期间功能可能需要调试运行多次才能保证功能命中，那每次run都会生成aar吗？如果是那不就多了一步从而增加了编译的开销时间，如果不是每次的话那什么时候去生成aar呢？(
功能命中后提交代码前吗？还是其他)
4、aar的方式作用之一是无需再参与编译吗？在你理解下还有更深的作用吗 ？
5、多工程每个业务模块都是一个工程，如果想了解整个项目的业务是不是需要用app壳工程引入所有方式？平时开发的时候只专注自己的模块就ok，对吗 ？
6、多工程下各自负责自己的业务模块，模块之间有新交互的话(
比如moduleA调用moduleB的一个服务,但moduleB可能还没有这个服务功能，那这个时候工作量是由moduleB对应人开发并暴露吗？可能有沟通成本，还是组件化的时候就已经规范了？)

AppLifeCycle插件，《Application生命周期分发》性能+解耦出发点真不错，简直是arouter-register的全量升级版

### 目录结构

- app
- course
- garden
- home
- me
- program
- .gradle
- .idea
- settings.gradle 文件： 用于确定哪些模块参与构建；
- 项目级 build.gradle 文件： 用于定义所有子模块公共的配置参数；
- 模块级 build.gradle 文件： 用于定义子模块的配置参数，它可以覆盖项目级 build.gradle 文件中定义的配置；
- gradle/warpper： 负责自动下载安装项目所需的 Gradle 环境的脚本；
    - gradle-wrapper.jar： 负责下载安装 Gradle 环境的脚本；
    - gradle-wrapper.properties： Gradle Wrapper 的配置文件，主要作用是决定 Gradle 版本和安装目录
- gradle.properties： 用作项目级 Gradle 配置项，会覆盖全局的配置项；
- local.properties： 用作项目的私有属性配置，例如 SDK 安装目录，一般不把 local.properties 加入版本控制。
- config.gradle
- gradlew 在 Linux 或 Mac 上可用的 Shell 脚本，以及在 Window 上可用的 Batch 脚本，用于以 Gradle Wrapper
  的方式执行构建。也就是说，在命令行使用 gradlew 才是基于 Gradle Wrapper 执行的，而使用 gradle 命令是直接基于系统安装的 Gradle 环境执行编译
- gradlew.bat 同上
- .gitignore

### 基础知识

#### Gradle
